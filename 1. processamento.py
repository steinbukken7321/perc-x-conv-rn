import os
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import zipfile

"""
üîπ Objetivo:
Este c√≥digo realiza um pipeline completo de processamento de imagens. 
Ele foi desenvolvido para ler imagens de uma pasta, pr√©-process√°-las e 
gerar sa√≠das prontas para serem utilizadas em treinamentos de modelos, 
an√°lises ou compress√µes.

‚úîÔ∏è FUNCIONALIDADES DO C√ìDIGO:
1Ô∏è‚É£ **Contagem e listagem de imagens na pasta**
   ‚û§ Filtra apenas arquivos de imagem (formatos: png, jpg, jpeg, bmp).

2Ô∏è‚É£ **Verifica√ß√£o dos tamanhos das imagens**
   ‚û§ Identifica se as imagens possuem tamanhos diferentes.

3Ô∏è‚É£ **Padroniza√ß√£o de formato**
   ‚û§ Converte todas as imagens da pasta para formato JPG em escala de cinza.

4Ô∏è‚É£ **Convers√£o para matrizes NumPy**
   ‚û§ Cada imagem √© convertida em uma matriz, onde cada elemento representa a 
      intensidade de cinza (valores de 0 a 255).

5Ô∏è‚É£ **Zero Padding**
   ‚û§ Adiciona uma borda de zeros nas imagens (tamanho configur√°vel) para 
      preservar as bordas durante opera√ß√µes de filtragem.

6Ô∏è‚É£ **Filtro de M√©dia**
   ‚û§ Aplica uma m√°scara NxN para suavizar a imagem, reduzindo ru√≠dos. 
      A m√©dia da vizinhan√ßa de cada pixel substitui o valor do pixel central.

7Ô∏è‚É£ **C√°lculo de estat√≠sticas**
   ‚û§ Mede a m√©dia e o desvio padr√£o da imagem original e da suavizada.

8Ô∏è‚É£ **Binariza√ß√£o**
   ‚û§ Converte a imagem suavizada para uma imagem bin√°ria (preto e branco), 
      utilizando um limiar adaptativo calculado como:
      ‚û§ limiar = m√©dia + (5 * desvio padr√£o)

9Ô∏è‚É£ **Exibi√ß√£o dos resultados**
   ‚û§ Mostra a imagem original, suavizada e binarizada lado a lado.
   ‚û§ Mostra tamb√©m o histograma de intensidades da imagem suavizada.

üîü **Salvamento dos dados**
   ‚û§ As matrizes das imagens originais e suavizadas s√£o salvas em arquivos `.npy`.
   ‚û§ Esses arquivos s√£o compactados em `.zip` para f√°cil armazenamento e transporte.
   ‚û§ Ap√≥s compactar, os arquivos `.npy` s√£o apagados do diret√≥rio para n√£o ocupar espa√ßo extra.

‚öôÔ∏è PAR√ÇMETROS CONFIGUR√ÅVEIS:
- `pasta_imagens` ‚Üí caminho onde est√£o as imagens.
- `size_padding` ‚Üí tamanho do zero padding aplicado nas bordas (ex.: 1, 2...).
- `filtro_size` ‚Üí tamanho da m√°scara do filtro de m√©dia (ex.: 3x3, 5x5...).

"""
##################################
# Contar imagens na pasta
##################################
def contareler_imagens(pasta):
    formatos_validos = {"png", "jpg", "jpeg", "bmp"}
    imagens = [f for f in os.listdir(pasta) if f.split(".")[-1].lower() in formatos_validos]
    return len(imagens), imagens

'''
se
"gato.png"
"cachorro.JPG"
"documento.pdf"
"letra.txt"
"pato.jpeg"

retorna:
quantidade de imagens (nesse caso seriam 3) e imagens:
["gato.png", "cachorro.JPG", "pato.jpeg"]

'''
##################################
# Obter tamanho das imagens
##################################
def obter_tamanho_imagens(pasta):
    _, imagens = contareler_imagens(pasta)
    tamanhos = set()
    
    for imagem in imagens:
        caminho = os.path.join(pasta, imagem)  
        with Image.open(caminho) as img:
            tamanhos.add(img.size)  # (largura, altura)
    
    return tamanhos

'''
path.join:
pasta = "C:/imagens"
imagem = "gato.jpg"
caminho = os.path.join(pasta, imagem)  # Resultado: "C:/imagens/gato.jpg"
'''

'''
se:
foto1.png	(28, 28)
foto2.png	(64, 64)
foto3.png	(28, 28)
foto4.png	(128, 128)
retorna:
{(28, 28), (64, 64), (128, 128)}
'''
##################################
# Padronizar formatos para JPG
##################################
def padronizar_formatos(pasta):
    _, imagens = contareler_imagens(pasta)
    formatos = set()
    
    for imagem in imagens:
        caminho = os.path.join(pasta, imagem)
        with Image.open(caminho) as img:
            formatos.add(img.format.lower())
    
    if len(formatos) > 1:
        for imagem in imagens:
            caminho = os.path.join(pasta, imagem)
            with Image.open(caminho) as img:
                novo_caminho = os.path.splitext(caminho)[0] + ".jpg"
                img.convert("L").save(novo_caminho, "JPEG")
                os.remove(caminho)



##################################
# Converter imagens para matrizes de intensidade
##################################
def converter_para_matriz(pasta):
    _, imagens = contareler_imagens(pasta)
    matrizes = []
    
    for imagem in imagens:
        caminho = os.path.join(pasta, imagem)
        with Image.open(caminho) as img:
            matriz = np.array(img, dtype=np.uint8) # transforma os pixels da imagem em uma matriz de n√∫meros inteiros (entre 0 e 255)
            matrizes.append(matriz)
    
    return matrizes # escala de cinza

'''
np.array(img) ‚Üí converte a imagem para uma matriz.
dtype=np.uint8 ‚Üí define que os valores v√£o de 0 a 255.

Retorna a lista matrizes, que cont√©m todas as imagens convertidas em matrizes NumPy
'''
##################################
# Obter tamanho de uma matriz
##################################
def obter_tamanho_matriz(matriz):
    linhas, colunas = matriz.shape
    return linhas, colunas, linhas * colunas

'''
verificar se tamanho da matriz √© = ao da imagem
'''
##################################
# Adicionar zero padding
##################################
def zero_padding(matrizes, size):
    return [np.pad(matriz, pad_width=size, mode='constant', constant_values=0) for matriz in matrizes]

'''
[[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]]

 size = 1
 [[0, 0, 0, 0, 0],
 [0, 1, 2, 3, 0],
 [0, 4, 5, 6, 0],
 [0, 7, 8, 9, 0],
 [0, 0, 0, 0, 0]]
'''

##################################
# Aplicar filtro de m√©dia NxN
##################################
def filtro_media(matrizes, filtro_size):
    pad = filtro_size // 2
    suavizadas = []

    for matriz in matrizes:
        altura, largura = matriz.shape
        nova_matriz = np.copy(matriz)

        # Percorre apenas os pixels que N√ÉO s√£o do padding
        for i in range(pad, altura - pad):
            for j in range(pad, largura - pad):
                # Extrai a regi√£o NxN ao redor do pixel atual
                vizinhanca = matriz[i-pad:i+pad+1, j-pad:j+pad+1]
                media = np.sum(vizinhanca) / (filtro_size ** 2)     # Calcula a m√©dia
                nova_matriz[i, j] = int(media)                      # Atualiza o pixel

        suavizadas.append(nova_matriz.astype(np.uint8))

    return suavizadas


'''

size = 1
[[0, 0, 0, 0, 0],
[0, 1, 2, 3, 0],
[0, 4, 5, 6, 0],
[0, 7, 8, 9, 0],
[0, 0, 0, 0, 0]]

(1,1) (1,2) (1,3)
(2,1) (2,2) (2,3)
(3,1) (3,2) (3,3)

Centrado no matriz[1][1] = 1
[ [0, 0, 0],
  [0, 1, 2],
  [0, 4, 5] ]
Soma: 0+0+0+0+1+2+0+4+5 = 12, m√©dia = 12 / 9 = 1.33 arredonda p/ 1
Resumo p/ exemplo:
(0,0) (0,1) (0,2) (0,3) (0,4)
(1,0)  ‚úîÔ∏è    ‚úîÔ∏è    ‚úîÔ∏è   (1,4)
(2,0)  ‚úîÔ∏è    ‚úîÔ∏è    ‚úîÔ∏è   (2,4)
(3,0)  ‚úîÔ∏è    ‚úîÔ∏è    ‚úîÔ∏è   (3,4)
(4,0) (4,1) (4,2) (4,3) (4,4)
'''


##################################
# Binarizar matrizes suavizadas
##################################
def binarizar_matrizes(matrizes, limiar=128):
    binarizadas = []
    for matriz in matrizes:
        binaria = (matriz >= limiar).astype(np.uint8) * 255  # 0 ou 255
        binarizadas.append(binaria)
    return binarizadas

##################################
# Exibir imagens
##################################
def exibir_imagens(originais, suavizadas, binarizadas):
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    titulos = ["Original", "Suavizada", "Binarizada"]
    imagens = [originais, suavizadas, binarizadas]
    
    for ax, img, titulo in zip(axes, imagens, titulos):
        ax.imshow(img, cmap='gray')
        ax.set_title(titulo)
        ax.axis('off')
    
    plt.tight_layout()
    plt.show()


##################################
# histograma
##################################
def exibir_histograma(matriz, titulo='Histograma de Intensidade'):
    plt.figure(figsize=(6, 4))
    plt.hist(matriz.ravel(), bins=50, color='gray', edgecolor='black')
    plt.title(titulo)
    plt.xlabel('Valor de Intensidade')
    plt.ylabel('Frequ√™ncia')
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

##################################
# Calcular desvio padr√£o do histograma (intensidade)
##################################
def calcular_desvio_padrao(matriz):
    return np.std(matriz)

##################################
# Salvar matrizes em .npy
##################################
def salvar_matrizes(nome_arquivo, matrizes):
    np.save(nome_arquivo, np.array(matrizes))
    print(f"Matrizes salvas em {nome_arquivo}")

##################################
# Compactar em zip
##################################
def compactar_npy(nome_arquivo_npy, nome_zip):
    with zipfile.ZipFile(nome_zip, 'w', zipfile.ZIP_DEFLATED) as zipf:
        zipf.write(nome_arquivo_npy)
    print(f"Arquivo compactado salvo como {nome_zip}")

##############################################
# CONFIGURA√á√ïES INICIAIS (PAR√ÇMETROS AJUST√ÅVEIS)
##############################################
pasta_imagens = r"C:\\Users\\rafae\\Desktop\\perc-x-conv-rn\\img"  # Caminho da pasta com imagens
size_padding = 1             # ‚û§ Tamanho do zero padding (ex: 1, 2, ...)
filtro_size = 3              # ‚û§ Tamanho da m√°scara do filtro de m√©dia (ex: 3, 5, ...)

##############################################
# PROCESSAMENTO DAS IMAGENS
##############################################
'''
# ‚è±Ô∏è In√≠cio do temporizador
tempo_inicio = time.time()
'''
# üì∏ Contagem de imagens e padroniza√ß√£o de formatos
quantidade, _ = contareler_imagens(pasta_imagens)
padronizar_formatos(pasta_imagens)

# üîÑ Convers√£o das imagens para matrizes
matrizes = converter_para_matriz(pasta_imagens)

# ‚ûï Aplica√ß√£o de zero padding
padded_matrices = zero_padding(matrizes, size_padding)

# üßπ Aplica√ß√£o do filtro de m√©dia
matrizes_suavizadas = filtro_media(padded_matrices, filtro_size)

# üìê M√©dias
media_original = np.mean(matrizes[0])
media = np.mean(matrizes_suavizadas[0])
# üìâ C√°lculo do desvio padr√£o da imagem suavizada
desvio_padrao = calcular_desvio_padrao(matrizes_suavizadas[0])
desvio_padrao_original = calcular_desvio_padrao(matrizes[0])


limiar = 5 * desvio_padrao + media  # ‚û§ Limiar para binariza√ß√£o (0 a 255)

# ‚¨õ Binariza√ß√£o das matrizes suavizadas com base no limiar
matrizes_binarizadas = binarizar_matrizes(matrizes_suavizadas, limiar)


# üìè Obten√ß√£o e exibi√ß√£o dos tamanhos das matrizes (original e com padding)
tamanho_original = obter_tamanho_matriz(matrizes[0])
tamanho_padded = obter_tamanho_matriz(padded_matrices[0])



'''
# ‚è±Ô∏è Fim do temporizador e c√°lculo do tempo total
tempo_fim = time.time()
tempo_total = tempo_fim - tempo_inicio
'''
# üìã Impress√£o de resultados
print(f"üìÇ Total de imagens: {quantidade}")

print(f"üìê Tamanho original da matriz: {tamanho_original[0]}x{tamanho_original[1]}")
print(f"üìê Tamanho ap√≥s zero padding: {tamanho_padded[0]}x{tamanho_padded[1]}")

print(f"üéØ Desvio padr√£o da matriz original: {desvio_padrao_original:.2f}")
print(f"üéØ Desvio padr√£o da matriz suavizada: {desvio_padrao:.2f}")

print(f"üìä M√©dia da matriz original: {media_original:.2f}")
print(f"üìä M√©dia da matriz suavizada: {media:.2f}")

print(f"üìê Limiar: 3*{desvio_padrao:.2f} + {media:.2f} = {limiar:.2f}")



# üìä Plot: histograma da matriz suavizada
exibir_histograma(matrizes_suavizadas[0])
# üìä Plot: imagem original, suavizada e binarizada
exibir_imagens(matrizes[0], matrizes_suavizadas[0], matrizes_binarizadas[0])



'''
print(f"‚è≥ Tempo total de execu√ß√£o: {tempo_total:.2f} segundos")



'''

# üíæ Salvamento das matrizes (lidas do zip) em arquivo .npy
npy_path_matrizes = "matrizes_tcc.npy"
zip_path_matrizes = "matrizes_tcc.zip"

salvar_matrizes(npy_path_matrizes, matrizes)
compactar_npy(npy_path_matrizes, zip_path_matrizes)
os.remove(npy_path_matrizes)

# üíæ Salvamento das matrizes suavizadas em arquivo .npy
npy_path_suavizadas = "matrizes_suavizadas_tcc.npy"
zip_path_suavizadas = "matrizes_suavizadas_tcc.zip"

salvar_matrizes(npy_path_suavizadas, matrizes_suavizadas)
compactar_npy(npy_path_suavizadas, zip_path_suavizadas)
os.remove(npy_path_suavizadas)

